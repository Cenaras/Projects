PARSER_BEGIN(Parser)
package Parsing;
import AST.*;
public class  Parser {
    public static void main(String[] args) {
                     try {
                         ASTNode result = new Parser(new java.io.StringReader(args[0])).S(); //Read the program from cmd line and parse with S() as start
                         //new Parser(new java.io.StringReader(args[0])).S();
                         System.out.println(result); //Print result of parsing
                     } catch (Throwable e) {
                         // Catching Throwable is ugly but JavaCC throws Error objects!
                         System.out.println("Syntax check failed: " + e.getMessage());
                         e.printStackTrace();
                     }
                 }
}
PARSER_END(Parser)

//ADD MORE STUFF HERE
TOKEN : {
    < INT : (["0"-"9"])+ >
    | < LET : "let" >
    | < ID : (["a"-"z"](["A"-"Z"])*)+ >
    | < PLUS : "+" >
    | < MINUS : "-" >
    | < TIMES : "*" >
    | < DIVIDE : "/" >
    | < SEMICOLON : ";" >
    | < ASSIGNEQ : "=" >

}
/*TODO: ADD PROPER DOCUMENTATION FOR THIS. ALSO ADD TEST PROGRAMS AND COMPARISIONS FOR THEM*/
//INTEGRATE COMMENTS HERE
SKIP : {
    " "
    | "\n"
    | "\t"
    | "\r"
}
//NOTES: javacc Lexing.jj, javac *.java afterwards. Add "package Lexing;" to files if it dissapears - or remove stuff from the package if it bothers you.

/*  PARSER AND GRAMMAR GOES HERE */
//< LET > <ID > < ASSIGNEQ > <INT>

ASTNode S(): {Exp e; Stm s;}
{
    e = Exp() <EOF> { return e; }
    | s = Stm() <EOF> { return s; }
}
Exp Exp(): {Exp e1; String op; Exp e2;}
{
    e1 = Term() (op = OpLvlOne() e2 = Term() { e1 = new BinOpExp(e1, op, e2); } )* //We only overwrite e1, if the Kleene-Star is taken. If it is, e1 is the new expression, if not, we keep e1 as the first term
    { return e1;}
}

Stm Stm(): {Token id; Token val;}
{
    < LET >  id = < ID > < ASSIGNEQ > val = <INT> < SEMICOLON > { return new LetStm(id.image, Integer.parseInt(val.image)); }
}

Exp Term(): {Exp e1; String op; Exp e2;}
{
    e1 = Literal() ( op = OpLvlTwo() e2 = Literal() {e1 = new BinOpExp(e1, op, e2); } )*
    { return e1; } //
}

Exp Literal(): {Token lit;}
{
    lit = <INT> {return new IntExp(Integer.parseInt(lit.image));}
}

String OpLvlTwo(): {Token op;}
{
    op = <TIMES> { return op.image; }
    | op = <DIVIDE> { return op.image; }
}

String OpLvlOne(): {Token op;}
{
    op = <PLUS> {return op.image; }
    | op = <MINUS> { return op.image; } //think correct
}

