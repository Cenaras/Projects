PARSER_BEGIN(Parser)
package Parsing;
import AST.*;
public class  Parser {
    public static void main(String[] args) {
                     try {
                         Exp result = new Parser(new java.io.StringReader(args[0])).S(); //Read the program from cmd line and parse with S() as start
                         System.out.println(result); //Print result of parsing
                     } catch (Throwable e) {
                         // Catching Throwable is ugly but JavaCC throws Error objects!
                         System.out.println("Syntax check failed: " + e.getMessage());
                         e.printStackTrace();
                     }
                 }
}
PARSER_END(Parser)

//ADD MORE STUFF HERE
TOKEN : {
    < INT : (["0"-"9"])+ >
    | < PLUS : "+" >
    | < MINUS : "-" >
    | < TIMES : "*" >
    | < DIVIDE : "/" >

}
/*TODO: ADD PROPER DOCUMENTATION FOR THIS. ALSO ADD TEST PROGRAMS AND COMPARISIONS FOR THEM*/
//INTEGRATE COMMENTS HERE
SKIP : {
    " "
    |"\n"
    | "\t"
}
//NOTES: javacc Lexing.jj, javac *.java afterwards. Add "package Lexing;" to files if it dissapears - or remove stuff from the package if it bothers you.
/*  PARSER AND GRAMMAR GOES HERE */
// int Exp(): {int x: x = T() (<PLUS> T())*; ret x}
//2 + 3
/*
* EXP, EOF
* EXP: T() + T()
* 2 + 3: EXP: T() + T()
*/
//Still requires to fix the returns of everything before generating the AST...
//Code is tests, needs to be fixed

Exp S(): {Exp e;}
{
    e = Exp() <EOF> { return e; }
}
Exp Exp(): {Exp e1; String op; Exp e2;}
{
    e1 = Term() (op = OpLvlOne() e2 = Term() { e1 = new BinOpExp(e1, op, e2); } )*
    { return e1;} //We only overwrite e1, if the Kleene-Star is taken. If it is, e1 is the new expression, if not, we keep e1 as the first term
}

Exp Term(): {Exp e1; String op; Exp e2;}
{
    e1 = Literal() ( op = OpLvlTwo() e2 = Literal() {e1 = new BinOpExp(e1, op, e2); } )*
    { return e1; } //
}

Exp Literal(): {Token lit;}
{
    lit = <INT> {return new IntExp(Integer.parseInt(lit.image));}
}

String OpLvlTwo(): {Token op;}
{
    op = <TIMES> { return op.image; }
    | op = <DIVIDE> { return op.image; }
}

String OpLvlOne(): {Token op;}
{
    op = <PLUS> {return op.image; }
    | op = <MINUS> { return op.image; } //think correct
}

