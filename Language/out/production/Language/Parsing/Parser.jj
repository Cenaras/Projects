PARSER_BEGIN(Parser)
package Parsing;
import AST.*;
import java.io.IOException;
import Exceptions.*;
import Util.*;
import java.nio.file.Files;
import java.nio.file.Paths;
public class  Parser {
    public static void main(String[] args) {
                     try {
                         String prefix = "D:\\CodingStuff\\Projects\\Projects\\Language\\tests\\";
                         String program = Files.readString(Paths.get(prefix+"test_files\\"+args[0]));
                         String expectedResult = Files.readString(Paths.get(prefix+"expected_results\\"+args[0]));
                         ASTNode result = new Parser(new java.io.StringReader(program)).S(); //Read the program from cmd line and parse with S() as start

                         if (!(result.toString().equals(expectedResult))) {
                             System.out.println("Expected was: " + expectedResult);
                             System.out.println("Actual was: " + result.toString());
                             throw new TestException("Comparision difference at index: " + Util.indexOfDifference(expectedResult, program));
                         }
                         System.out.println("Test successful!");

                     } catch (Throwable e) {
                         // Catching Throwable is ugly but JavaCC throws Error objects!
                         System.out.println("Syntax check failed: " + e.getMessage());
                         e.printStackTrace();
                     }
                 }
}
PARSER_END(Parser)

//ADD MORE STUFF HERE
TOKEN : {
    < INT : (["0"-"9"])+ >
    | < LET : "let" >
    | < ID : (["a"-"z"](["A"-"Z"])*)+ >
    | < PLUS : "+" >
    | < MINUS : "-" >
    | < TIMES : "*" >
    | < DIVIDE : "/" >
    | < SEMICOLON : ";" >
    | < ASSIGNEQ : "=" >

}
/*TODO: ADD PROPER DOCUMENTATION FOR THIS. ALSO ADD TEST PROGRAMS AND COMPARISIONS FOR THEM*/
//INTEGRATE COMMENTS HERE
SKIP : {
    " "
    | "\n"
    | "\t"
    | "\r"
}
//NOTES: javacc Lexing.jj, javac *.java afterwards. Add "package Lexing;" to files if it dissapears - or remove stuff from the package if it bothers you.

/*  PARSER AND GRAMMAR GOES HERE */
//< LET > <ID > < ASSIGNEQ > <INT>

ASTNode S(): {Exp e; Stm s;}
{
    e = Exp() <EOF> { return e; }
    | s = Stm() <EOF> { return s; }
}
Exp Exp(): {Exp e1; String op; Exp e2;}
{
    e1 = Term() (op = OpLvlOne() e2 = Term() { e1 = new BinOpExp(e1, op, e2); } )* //We only overwrite e1, if the Kleene-Star is taken. If it is, e1 is the new expression, if not, we keep e1 as the first term
    { return e1;}
}

Stm Stm(): {Token id; Exp exp;}
{
    < LET >  id = < ID > < ASSIGNEQ > exp = Exp() < SEMICOLON > { return new LetStm(id.image, exp); }
}

Exp Term(): {Exp e1; String op; Exp e2;}
{
    e1 = Literal() ( op = OpLvlTwo() e2 = Literal() {e1 = new BinOpExp(e1, op, e2); } )*
    { return e1; } //
}

Exp Literal(): {Token lit;}
{
    lit = <INT> {return new IntExp(Integer.parseInt(lit.image));}
}

String OpLvlTwo(): {Token op;}
{
    op = <TIMES> { return op.image; }
    | op = <DIVIDE> { return op.image; }
}

String OpLvlOne(): {Token op;}
{
    op = <PLUS> {return op.image; }
    | op = <MINUS> { return op.image; } //think correct
}

